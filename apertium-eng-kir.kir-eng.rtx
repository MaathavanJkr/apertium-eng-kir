!!! ATTRIBUTE LISTS !!!

number = (ND sg) sg pl sp ;
case = (CD subj) nom acc dat gen loc abl subj obj ;
oblique = (CD obj) acc dat loc abl obj ;
prontype = pers dem ;
!tenseetc = ifi past aor pres prc_perf prc_ipf ;
!nonfinite = prc_perf, pprs, prc_impf, pprs ;
person = (PD p3) p1 p2 p3 ;
transitivity = tv iv cop ;
gender = (GD m) m f mf nt ;
definiteness = (DD def) ind def ;
prep_flag = (PRD none) to in on at for of from PRD none;
                 ! ^ hack, but not all NPs have prep_flag set, which overrides <dat> and this no pr
adjlevel = cmp ;
adjtype = sint ;
adv_behaviour = attr ;
advlevel = cmp ;
nptype = n np ;
det_type = dem ;
negative = (pos pos) neg pos ;

fnf = fin prc vadj vadv ger ;
    ! finite, non-finite
tense = (TD pres) pres aor ifi past qst ;  ! finites
    ! use <qst>
prc = (PTD pprs) prc_past prc_impf prc_irre pprs pp ;  ! select -ing if in doubt
vadv = gna_perf ;
ger = ger ger_past ;
vadj = gpr_past ;
voice = pass caus ;
passive = pass ;
fnfall = [tense] [prc] [vadv] [ger] [vadj] ;

poss = (PSD noPOSS) px1sg px2sg px3sg px1pl px2pl px3pl px3sp noPOSS;
px3 = px3sp px3sg px3pl ;

en_nouns_mass = bread paper ;
en_nouns_count = window paper ;

en_verbs_nopr = believe touch enter reach cross leave;
ky_verbs_dat_arg = ишен тий кир жет;
ky_verbs_abl_arg = өт аш;
en_vaux_ing = be ;
en_vaux_to = want ;
en_vaux_none = can ;

en_vaux_person = be have ;

might_get_pr = loc dat abl gen ;

city = Нарын ;


!!! MAPPINGS !!!

poss > person : px1sg p1, px2sg p2, px3sg p3, px1pl p1, px2pl p2, px3pl p3, px3sp p3;
poss > number : px1sg sg, px2sg sg, px3sg sg, px1pl pl, px2pl pl, px3pl pl, px3sp sg;
poss > gender : px1sg mf, px2sg mf, px3sg nt, px1pl mf, px2pl mf, px3pl mf, px3sp nt;
tense > tense : aor pres, ifi past ;
nonfinite > nonfinite : prc_perf pprs, prc_impf pprs ;
prc > tense : prc_perf pprs, prc_impf pprs ;
case > case : nom subj, acc obj, dat obj ;
case > prep_flag : dat to, abl from, gen of, loc at, acc none, nom none;
fnfall > fnf : [tense] fin, [prc] prc, [vadv] vadv, [ger] ger, [vadj] vadj ;

!!! OUTPUT PATTERNS !!!
! when building chunk or lu of this type, put these tags in this order

NP: _.nptype.number.poss.case.prep_flag ;
DP: _.case.prep_flag ;
VP: _.fnf.transitivity.tense.person.number.negative ;
np: _ ;
prn: _.case.person.gender.number ;
S: _ ;
n: _.number ;
adj: _.adjtype.adjlevel ;
post: _;
vP: _.transitivity.tense.fnf.person.number.negative ;
PP: _.prep_flag ;
AP: _ ;
det_dem: _.<dem>.number ;
det_def: _.definiteness.number ;
det: (if (1.det_type = dem) 1[det_dem] else 1[det_def]);
adv_attr: _ ;
adv_default: _.advlevel ;
adv: (if (1.adv_behaviour = attr) 1[adv_attr] else 1[adv_default]);

vaux_pers: _.tense.person.number ;
vaux_nopers: _.tense ;
vaux: (if (1.tense = qst) 1[vaux_nopers](tense=inf)
       else-if (1.lem/tl not in en_vaux_person) 1[vaux_nopers]
       else 1[vaux_pers]);
cop: _.tense.person.number ;
vbdo: _.tense.person.number ;
vbser: _.tense.person.number ;

verb_pers: pos_tag.tense.person.number;
verb_nopers: pos_tag.tense;
verb: (if (1.tense = qst)
          1[verb_nopers](tense=inf)
       else-if (1.tense = pres and 1.person = p3 and 1.number = sg)
          (if (1.negative = neg)
              [ 1[verb_pers] + not@adv ]
           else
              1[verb_pers])
       else
          (if (1.negative = neg)
              [ 1[verb_nopers] + not@adv ]
           else
              1[verb_nopers])
       );
v: (always 1[verb]);
vblex: (always 1[verb]);

!vaux_thing: lemh.<vbser>.tense.person.number ;

!!! MACROS !!!

qst_front: (if (1.lem = жат or 1.lem = э)
              be[verb](pos_tag=vbser, tense=1.tense, person=1.person, number=1.number, negative=1.negative, lemcase=1.lemcase)
            else-if (1.lem = ал)
              can[verb](pos_tag=vbmod, tense=1.tense, person=1.person, number=1.number, negative=1.negative, lemcase=1.lemcase)
            else
              do[verb](pos_tag=vbdo, tense=1.tense, person=1.person, number=1.number, negative=1.negative, lemcase=1.lemcase)
           );


!!! RULES !!!

NP ->	0: np.$nptype.$lem/sl.$case/sl.$poss [$number=sg] { 1 } |
      1: n.$nptype.$lem/sl.$case/sl.$number.$poss [$prep_flag=1.case/sl>prep_flag] { 1 } |
      2: np.top.loc.$nptype.$poss ?(1.lem/sl in city) [$case=loc,$prep_flag=in,$number=sg] { 1 } |
      3: np.top.loc.$nptype.$poss                     [$case=loc,$prep_flag=on,$number=sg] { 1 } |
!      2: np.top.loc.$nptype.$poss [$case=loc,$number=sg] { in@prep _ 1 } (1.lem/sl in city)
!                                { at@prep _ 1 } |
      4: n.nom n.px3sp.$case.$nptype [$number=sg,$poss=2.poss] { 1 _1 2 }
   ;

AP -> adj { 1 } |
      adv.attr { 1 } ;
!|
 !     AP { 1 } ;

DP -> 1: NP.gen NP.px3.$case.$prep_flag { 1 's@gen _1 2 } |
      2: NP.gen NP.px3.$case.$prep_flag { 2 _1 of@pr _ 1 } |
      det NP.$case.$prep_flag { 1(number=2.number) _1 2 } |
      det AP NP.$case.$prep_flag { 1 _1 2 _2 3 } |
      0: NP.$case.$prep_flag {
          (if (1.poss = noPOSS)
               [ the@det.def.sp ]
             else
               [ prpers@det.pos.[1.poss>person].[1.poss>gender].[1.poss>number] ]
          ) _ 1 } |
      1: NP.$case.$prep_flag { a@det.idf.sp _ 1 } |
      0: AP NP.$case.$prep_flag { the@det.def.sp _ 1 _1 2 } |
      1: AP NP.$case.$prep_flag { a@det.idf.sp _ 1 _1 2 } |
      2: prn.$case { (if (1.person = p1 and 1.number = sg) 1(lemcase=Aa)
                      else 1(lemcase=$lemcase)) } |
      VP.prc DP.$case { 2 _1 that@cnjsub _ 1 }
   ;

PP -> DP.$prep_flag ?(1.case in might_get_pr)
         (if ($prep_flag = none)
             { 1 }
          else
             { (if (($prep_flag = to) or (1.case = dat))
                   [ to@pr _ ]
                else-if ($prep_flag = at)
                   [ at@pr _ ]
                else-if ($prep_flag = in)
                   [ in@pr _ ]
                else-if ($prep_flag = on)
                   [ on@pr _ ]
                else-if ($prep_flag = of)
                   [ of@pr _ ]
                else-if ($prep_flag = from)
                   [ from@pr _ ]
                else
                   []
                )
                1 } ) |
      DP post { 2 _1 1 } ;

VP -> PP DP.[definiteness].prep_flag %vP { 3 _2 2 _1 1 } |
      DP.[definiteness].prep_flag DP.[definiteness].prep_flag %vP { 3 _2 2 _1 1 } |
!      DP.oblique DP.acc %vP { 3 _2 2 _1 1 } |
      DP %vP.cop { 2 _1 1 } |
      AP %vP.cop { 2 _1 1 } |
      DP DP %vP
!         ?(~((1.case = nom) and (2.case = nom) and ((3.fnf = prc) or (3.transitivity = cop)))) ! don't match <nom> <nom> <prc> or <nom> <nom> <cop> → these are handled by other rules
         ?(
            ((2.case = nom) and (1.case in might_get_pr)) or
            ((2.case = acc) and (1.case in might_get_pr))
          )
            (if ((1.case = nom) and (2.case = acc))
                { 1 _1 3 _2 2 }
             else
                { 3 _2 2 _1 1 } ) |
      DP %vP.$lem
         ?(not
            (
               ((2.passive = pass) or (2.transitivity = iv))
               and (1.case = nom)
            )
          ) { %2 _1 1 } |
      PP DP.acc %vP { 3 _2 2 _1 1 } |
      PP PP %vP { 3 _2 2 _1 1 } |
      PP %vP
         { 2 _1
            (if (2.lem in ky_verbs_dat_arg)
               1(prep_flag=none)
             else
               1
            )
         } |
      %vP { 1 }
   ;


!      0: v.$transitivity { 1 } |
!      1: NP.acc v.$transitivity { 2 _1 1 } |
!      2: NP NP v.$transitivity
!         { 3 _2 the@det.def.sp _2 2 _1 to@pr 1 }
!         { 3 _2 the@det.def.sp _2 2 _1 1 }        ( 3.lem in en_verbs_nopr )
!    |
!      3: DP. VP                                   ( 3.lem in en_verbs_nopr )
!      4: NP.dat NP.nom v.$transitivity { 3 _2 2 _1 1 } ;

!v -> 0: v.$tenseetc vaux { 2[vaux_thing] _1 1 } ;
!v -> 0: v.$tenseetc vaux.$tense { 2 _1 1 } ;

prc_or_tense = [prc] [tense] ;
prc_or_tense > tense : prc_past past ;
frontable = be can ;

vP -> 0: v.$transitivity %vaux.$tense.$lem/sl [$fnf=1.fnfall>fnf]
          (if (2.lem/tl in frontable and $tense = qst)
              { (if (2.lem/tl = be) 1(tense=pprs, negative=pos) else 1(tense=inf, negative=pos)) }
           else-if (2.lem in en_vaux_ing)
              { 2(tense=$tense) _1 1(tense=pprs) }
           else-if (2.lem in en_vaux_none)
              { 2(tense=$tense) _1 1(tense=inf) }
           else ! 2.lem in en_vaux_to
              { 2(person=1.person, number=1.number, tense=$tense) _1 to@pr _1 1(tense=inf) } )
       |
      !1: v.$transitivity.$tense [$fnf=1.fnfall>fnf]
      !    (if ((1.person=p3) and (1.number=sg))
      !        { 1(person=p3, number=sg) }
      !     else
      !        { 1(person=_, number=_) }
      !    )
      ! |
      1: %v.$transitivity.$lem/sl [$fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          (if ((1.passive/sl = pass) and ($tense not = qst))
              { be@vbser.$tense.[1.person].[1.number] _ 1(tense=pp) }
           else
              { 1(tense=$tense) } ) |
      2: %v.*.neg.$transitivity.$lem/sl [$fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          (if ($tense = qst)
              { 1(tense=inf, negative=pos) }
           else
              { do@vbdo.$tense _ not@adv _ 1(tense=inf, negative=pos) } ) |

      3: %cop.$lem/sl [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) } |
      4: %cop.neg.$lem/sl [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) _ not@adv } |

      3: %бол@v ?(1.lem/tl = be) [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) } |
      4: %бол@v.*.neg ?(1.lem/tl = be) [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) _ not@adv } ;



S -> DP.nom VP.fin { 1 _1 2 } |
     DP.nom.$lemcase VP qst { 2[qst_front](lemcase=$lemcase) _ 1(lemcase=aa) _1 2(tense=qst) } ;
