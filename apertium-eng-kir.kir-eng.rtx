!!! ATTRIBUTE LISTS !!!

number = (ND sg) sg pl sp ;
case = (CD subj) acc dat gen loc abl subj obj ;
prontype = pers dem ;
tense = (TD pres) pres aor ifi past ;
!tenseetc = ifi past aor pres prc_perf prc_ipf ;
!nonfinite = prc_perf, pprs, prc_impf, pprs ;
person = (PD p3) p1 p2 p3 ;
prc = (PTD pprs) prc_perf prc_ipf prc_irre pprs ;  ! select -ing if in doubt
transitivity = tv iv ;
gender = (GD m) m f mf nt ;
definiteness = (DD def) ind def ;
prep_flag = (PRD none) to in on at for ;
adjlevel = cmp ;
adjtype = sint ;

poss = px1sg px2sg px3sg px1pl px2pl px3pl;

en_nouns_mass = bread paper ;
en_nouns_count = window paper ;

en_verbs_nopr = believe ;
en_vaux_ing = be ;
en_vaux_to = want ;

en_vaux_person = be have ;

might_get_pr = loc dat abl gen ;

city = Нарын ;


!!! MAPPINGS !!!

poss > person : px1sg p1, px2sg p2, px3sg p3, px1pl p1, px2pl p2, px3pl p3;
poss > number : px1sg sg, px2sg sg, px3sg sg, px1pl pl, px2pl pl, px3pl pl;
tense > tense : aor pres, ifi past ;
nonfinite > nonfinite : prc_perf pprs, prc_impf pprs ;
prc > tense : prc_perf pprs, prc_impf pprs ;
case > case : nom subj, acc obj, dat obj ;


!!! PATTERNS !!!
! when building chunk or lu of this type, put these tags in this order

NP: _.case.prep_flag ;
DP: _.case.prep_flag ;
VP: _ ;
np: _ ;
prn: _.case.person.gender.number ;
S: _ ;
n: _.number ;
v: _.tense ;
adj: _.adjtype.adjlevel ;
vP: _.transitivity.tense ;
PP: _ ;
AP: _ ;
vAux: _.tense.person.number ;
vaux: _.tense.person.number ;
!vbser: _.tense.person.number ;

!vaux_thing: lemh.<vbser>.tense.person.number ;


!!! RULES !!!

NP ->	0: np.$lem/sl.$case/sl { 1 } |
      1: n.$lem/sl.$case/sl { 1 } |
      2: np.top.loc [$case=loc,$prep_flag=in] (1.lem/sl in city) { 1 } |
      3: np.top.loc [$case=loc,$prep_flag=on]                    { 1 } |
!      2: np.top.loc [$case=loc] { in@prep _ 1 } (1.lem/sl in city)
!                                { at@prep _ 1 } |
      4: n.nom n.px3sp.$case { 1 _1 2 }
   ;

AP -> adj { 1 } ;
!|
 !     AP { 1 } ;

DP -> 0: NP.$case.$prep_flag { the@det.def.sp _ 1 } |
      1: NP.$case.$prep_flag { a@det.idf.sp _ 1 } |
      0: AP NP.$case.$prep_flag { the@det.def.sp _ 1 _1 2 } |
      1: AP NP.$case.$prep_flag { a@det.idf.sp _ 1 _1 2 } |
      2: prn.$case { 1 }
   ;

PP -> DP (1.case in might_get_pr)
           {to@pr _ 1}    (1.case = dat)
           { 1 }          ($prep_flag = none)
           {to@pr _ 1}    ($prep_flag = to)
           {at@pr _ 1}    ($prep_flag = at)
           {in@pr _ 1}    ($prep_flag = in)
           {on@pr _ 1}    ($prep_flag = on)
   ;

VP -> PP DP.definiteness.prep_flag vP.$transitivity { 3 _2 2 _1 1 } |
      DP.definiteness.prep_flag DP.definiteness.prep_flag vP.$transitivity { 3 _2 2 _1 1 } |
      DP DP vP { 3 _2 2 _1 1 } |
      PP NP.acc vP { 3 _2 2 _1 1 }
   ;


!      0: v.$transitivity { 1 } |
!      1: NP.acc v.$transitivity { 2 _1 1 } |
!      2: NP NP v.$transitivity
!         { 3 _2 the@det.def.sp _2 2 _1 to@pr 1 }
!         { 3 _2 the@det.def.sp _2 2 _1 1 }        ( 3.lem in en_verbs_nopr )
!    |
!      3: DP. VP                                   ( 3.lem in en_verbs_nopr )
!      4: NP.dat NP.nom v.$transitivity { 3 _2 2 _1 1 } ;

!v -> 0: v.$tenseetc vaux { 2[vaux_thing] _1 1 } ;
!v -> 0: v.$tenseetc vaux.$tense { 2 _1 1 } ;

vP -> 0: v.$transitivity vAux.$tense
          { 2 _1 1(tense=pprs) } ( 2.lem in en_vaux_ing )
          { 2(person=1.person,number=1.number) _1 to@pr _1 1(tense=inf) } ( 2.lem in en_vaux_to ) |
      v.$transitivity { 1 } ;

vAux -> vaux.$lemh { 1(person=_,number=_) } ( ~( 1.lem in en_vaux_person ) )
                   { 1 }
     ;



S -> 0: DP VP.iv { 1 _1 2 } |
     1: DP.nom VP.iv { 1 _1 2 } |
     2: DP.nom VP.tv { 1 _1 2 } ;
