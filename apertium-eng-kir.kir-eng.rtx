!!! ATTRIBUTE LISTS !!!

number = (ND sg) sg pl sp ;
case = (CD subj) nom acc dat gen loc abl subj obj ;
oblique = (CD obj) acc dat loc abl obj ;
prontype = pers dem ;
!tenseetc = ifi past aor pres prc_perf prc_ipf ;
!nonfinite = prc_perf, pprs, prc_impf, pprs ;
person = (PD p3) p1 p2 p3 ;
transitivity = tv iv ;
gender = (GD m) m f mf nt ;
definiteness = (DD def) ind def ;
prep_flag = (PRD noneb) to in on at for PRD none;
                 ! ^ hack, but not all NPs have prep_flag set, which overrides <dat> and this no pr
adjlevel = cmp ;
adjtype = sint ;
nptype = n np ;
det_type = dem ;

fnf = fin prc vadj vadv ger ;
    ! finite, non-finite
tense = (TD pres) pres aor ifi past ;  ! finites
prc = (PTD pprs) prc_past prc_impf prc_irre pprs ;  ! select -ing if in doubt
vadv = gna_perf ;
ger = ger ger_past ;
vadj = gpr_past ;
fnfall = [tense] [prc] [vadv] [ger] [vadj] ;

poss = px1sg px2sg px3sg px1pl px2pl px3pl;

en_nouns_mass = bread paper ;
en_nouns_count = window paper ;

en_verbs_nopr = believe ;
en_vaux_ing = be ;
en_vaux_to = want ;

en_vaux_person = be have ;

might_get_pr = loc dat abl gen ;

city = Нарын ;


!!! MAPPINGS !!!

poss > person : px1sg p1, px2sg p2, px3sg p3, px1pl p1, px2pl p2, px3pl p3;
poss > number : px1sg sg, px2sg sg, px3sg sg, px1pl pl, px2pl pl, px3pl pl;
tense > tense : aor pres, ifi past ;
nonfinite > nonfinite : prc_perf pprs, prc_impf pprs ;
prc > tense : prc_perf pprs, prc_impf pprs ;
case > case : nom subj, acc obj, dat obj ;
fnfall > fnf : [tense] fin, [prc] prc, [vadv] vadv, [ger] ger, [vadj] vadj ;

!!! PATTERNS !!!
! when building chunk or lu of this type, put these tags in this order

NP: _.nptype.case.prep_flag.number ;
DP: _.case.prep_flag ;
VP: _.fnf ;
np: _ ;
prn: _.case.person.gender.number ;
S: _ ;
n: _.number ;
v: _.tense ;
adj: _.adjtype.adjlevel ;
vP: _.transitivity.tense.fnf;
PP: _ ;
AP: _ ;
det_dem: _.<dem>.number ;
det_def: _.definite.number ;
det: (if (1.det_type = dem) 1[det_dem] else 1[det_def]);
vAux: _.tense.person.number ;
vaux: _.tense.person.number ;
!vbser: _.tense.person.number ;

!vaux_thing: lemh.<vbser>.tense.person.number ;


!!! RULES !!!

NP ->	0: np.$nptype.$lem/sl.$case/sl [$number=sg] { 1 } |
      1: n.$nptype.$lem/sl.$case/sl.$number { 1 } |
      2: np.top.loc.$nptype ?(1.lem/sl in city) [$case=loc,$prep_flag=in,$number=sg] { 1 } |
      3: np.top.loc.$nptype                     [$case=loc,$prep_flag=on,$number=sg] { 1 } |
!      2: np.top.loc.$nptype [$case=loc,$number=sg] { in@prep _ 1 } (1.lem/sl in city)
!                                { at@prep _ 1 } |
      4: n.nom n.px3sp.$case.$nptype [$number=sg] { 1 _1 2 }
   ;

AP -> adj { 1 } ;
!|
 !     AP { 1 } ;

DP -> det NP.$case.$prep_flag { 1(number=2.number) _1 2 } |
      det AP NP.$case.$prep_flag { 1 _1 2 _2 3 } |
      0: NP.$case.$prep_flag { the@det.def.sp _ 1 } |
      1: NP.$case.$prep_flag { a@det.idf.sp _ 1 } |
      0: AP NP.$case.$prep_flag { the@det.def.sp _ 1 _1 2 } |
      1: AP NP.$case.$prep_flag { a@det.idf.sp _ 1 _1 2 } |
      2: prn.$case { 1 } |
      VP.prc DP.$case { 2 _1 that@cnjsub _ 1 }
   ;

PP -> DP ?(1.case in might_get_pr)
         (if (1.prep_flag = none)
             { 1 }
          else
             { (if ((1.prep_flag = to) or (1.case = dat))
                   [ to@pr _ ]
                else-if (1.prep_flag = at)
                   [ at@pr _ ]
                else-if (1.prep_flag = in)
                   [ in@pr _ ]
                else-if (1.prep_flag = on)
                   [ on@pr _ ]
                else-if (1.case = gen)
                   [ of@pr _ ]
                else
                   []
                )
                1 } );

VP -> PP DP.definiteness.prep_flag vP.$transitivity.$fnf { 3 _2 2 _1 1 } |
      DP.definiteness.prep_flag DP.definiteness.prep_flag vP.$transitivity.$fnf { 3 _2 2 _1 1 } |
      DP.oblique DP.acc vP.$fnf { 3 _2 2 _1 1 } |
      PP DP.acc vP.$fnf { 3 _2 2 _1 1 }
   ;


!      0: v.$transitivity { 1 } |
!      1: NP.acc v.$transitivity { 2 _1 1 } |
!      2: NP NP v.$transitivity
!         { 3 _2 the@det.def.sp _2 2 _1 to@pr 1 }
!         { 3 _2 the@det.def.sp _2 2 _1 1 }        ( 3.lem in en_verbs_nopr )
!    |
!      3: DP. VP                                   ( 3.lem in en_verbs_nopr )
!      4: NP.dat NP.nom v.$transitivity { 3 _2 2 _1 1 } ;

!v -> 0: v.$tenseetc vaux { 2[vaux_thing] _1 1 } ;
!v -> 0: v.$tenseetc vaux.$tense { 2 _1 1 } ;

vP -> 0: v.$transitivity vAux.$tense [$fnf=1.fnfall>fnf]
          (if (2.lem in en_vaux_ing)
              { 2 _1 1(tense=pprs) }
           else ! 2.lem in en_vaux_to
              { 2(person=1.person, number=1.number) _1 to@pr _1 1(tense=inf) } )
       |
      1: v.$transitivity.$tense [$fnf=1.fnfall>fnf]
          (if ((1.person=p3) and (1.number=sg))
              { 1(person=p3, number=sg) }
           else
              { 1(person=_, number=_) }
          )
       |
      2: v.$transitivity.$tense [$fnf=1.fnfall>fnf]
          { 1 } ;

!TOTAL_HACK: _;
!TOTAL_HACK -> vP TOTAL_HACK ?(x not equal x) { 1 _1 2 };
! this rule never applies, but the fact that it exists
! ensure that paths ending in vP will not be discarded for being dead ends

vAux -> vaux.$lemh (if (1.lem not in en_vaux_person)
                       { 1(person=_, number=_) }
                    else
                       { 1 } )
     ;



S -> 0: DP VP.iv { 1 _1 2 } |
     1: DP.nom VP.iv { 1 _1 2 } |
     2: DP.nom VP.tv { 1 _1 2 } ;
