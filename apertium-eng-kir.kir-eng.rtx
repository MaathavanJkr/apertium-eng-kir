!!! ATTRIBUTE LISTS !!!

number = (ND sg) sg pl sp ;
case = (CD subj) nom acc dat gen loc abl subj obj ;
oblique = (CD obj) acc dat loc abl obj ;
prontype = pers dem ;
!tenseetc = ifi past aor pres prc_perf prc_ipf ;
!nonfinite = prc_perf, pprs, prc_impf, pprs ;
person = (PD p3) p1 p2 p3 ;
transitivity = tv iv cop ;
gender = (GD m) m f mf nt ;
definiteness = (DD def) ind def ;
prep_flag = (PRD NOpr) to in on at for of from PRD NOpr; !none;
adjlevel = comp ;
adjtype = sint ;
adv_behaviour = (AdvBD NOadvB) attr ;
adj_behaviour = advl subst ;
advlevel = comp ;
nptype = n np prn ;
det_type = dem ;
np_type = top cog ant ;
prn_type = itg rel ind ;
negative = (pos pos) neg pos ;

fnf = fin prc vadj vadv ger ;
    ! finite, non-finite
tense = (TD pres) pres aor ifi past ;  ! finites
qst = (QD NOqst) qst NOqst ;
    ! use <qst>
prc = (PTD pprs) prc_past prc_impf prc_irre pprs pp ;  ! select -ing if in doubt
en_nonfin = (NFD noNF) pprs pp inf noNF ;

vadv = gna_perf ;
ger = ger ger_past ;
vadj = gpr_past ;
voice = pass caus ;
passive = pass ;
fnfall = [tense] [prc] [vadv] [ger] [vadj] ;

poss = (PSD noPOSS) px1sg px2sg px3sg px1pl px2pl px3pl px3sp noPOSS;
px3 = px3sp px3sg px3pl ;

en_nouns_mass = bread paper ;
en_nouns_count = window paper ;

en_nouns_loc_in = garden taxi cab car house attic building cabinet agreement ;
en_nouns_loc_on = bus floor roof shelf motorcycle bicycle plane airplane ship boat ;
en_nouns_loc_at = concert school club game address shore ;
! FIXME: multiple options, depending on meaning:
! beach - on, at
! road - on, in

en_verbs_nopr = believe touch enter reach cross leave;
ky_verbs_dat_arg = ишен тий кир жет;
ky_verbs_abl_arg = өт аш;

en_vaux_ing = be finish start begin like ;
en_vaux_to = want ;  ! FIXME: like
en_vaux_none = can ;

ky_verbs_ing = башта бүтүр "жакшы көр" ;

en_vaux_person = be have ;

ky_titles = байке эже мырза айым ;

might_get_pr = loc dat abl gen ;

city = Нарын ;

prep_nouns = арт алд жан үст аст орто маңдай түп ара ич ;


!!! MAPPINGS !!!

poss > person : px1sg p1, px2sg p2, px3sg p3, px1pl p1, px2pl p2, px3pl p3, px3sp p3;
poss > number : px1sg sg, px2sg sg, px3sg sg, px1pl pl, px2pl pl, px3pl pl, px3sp sg;
poss > gender : px1sg mf, px2sg mf, px3sg nt, px1pl mf, px2pl mf, px3pl mf, px3sp nt;
tense > tense : aor pres, ifi past ;
nonfinite > nonfinite : prc_perf pprs, prc_impf pprs ;
ger > tense : ger pprs, ger_past pprs ;
prc > tense : prc_perf pprs, prc_impf pprs ;
case > case : nom subj, acc obj, dat obj ;
case > prep_flag : dat to, abl from, gen of, loc at, acc NOpr, nom NOpr, subj NOpr, obj NOpr;
fnfall > fnf : [tense] fin, [prc] prc, [vadv] vadv, [ger] ger, [vadj] vadj ;
lemh > preposition : арт behind, алд "in front of", жан "next to", үст "on top of", аст under, орто "in the middle of", маңдай "across from", түп "at the bottom of", ара between, ич inside ;

!!! OUTPUT PATTERNS !!!
! when building chunk or lu of this type, put these tags in this order

NP: _.nptype.number.poss.case.prep_flag ;
DP: _.nptype.number.poss.case.prep_flag ;
dP: _.nptype.number.poss.case.prep_flag ;
VP: _.fnf.transitivity.tense.person.number.negative.qst.en_nonfin ;
RC: _ ;
prn_pers: _.case.person.gender.number ;
prn_itg: _.<itg>.gender.number ;
prn_ind: _.<ind>.gender.number ;
prn: (if (1.prn_type = itg) 1(prn_itg) else-if (1.prn_type = ind) 1(prn_ind) else 1(prn_pers));
S: _ ;
n: _.number ;
adj: _.adjtype.adjlevel ;
post: _;
vP: _.transitivity.tense.fnf.person.number.negative.qst.en_nonfin ;
PP: _.prep_flag ;
AP: _ ;
det_dem: _.<dem>.number ;
det_def: _.definiteness.number ;
det: (if (1.det_type = dem) 1(det_dem) else 1(det_def));
adv_attr: _ ;
adv_default: _.advlevel ;
adv: (if (1.adv_behaviour = attr) 1(adv_attr) else 1(adv_default));
AdvP: _.advlevel ;
np_top: _.<top> ;
np_ant: _.<ant>.gender.number ;
np_cog: _.<cog>.gender ;
np_default: _ ;
np: (if (1.np_type = top) 1(np_top) else-if (1.np_type = ant) 1(np_ant) else-if (1.np_type = cog) 1(np_cog) else 1(np_default));
num: _.number ;
cnjcoo: _ ;

cop: _.tense.person.number ;
vbdo: _.tense.person.number ;
vbser: _.tense.person.number ;

verb_pers: pos_tag.tense.person.number;
verb_nopers: pos_tag.tense;
verb_nonfin: pos_tag.en_nonfin;

! should this macro deal with do-support?
! if so, it should check for (1.negative = neg) and generate do(vbdo)[...] not@adv
verb: (if (1.qst = qst)
          1(verb_nopers)[tense=inf]
       else-if (1.en_nonfin not = noNF)
          1(verb_nonfin)
       else-if (1.tense>tense = pres and 1.person = p3 and 1.number = sg)
          1(verb_pers)
       else
          1(verb_nopers));
v: (always 1(verb));
vblex: (always 1(verb));

vaux: (if (1.qst = qst)
          1(verb_nopers)[tense=inf]
       else-if ((1.tense>tense = pres) and
                ( (1.pos_tag = vbser and (1.person = p1 or 1.person = p3))
                  or
                  (1.person = p3 and 1.number = sg)))
          (if (1.negative = neg)
              [ 1(verb_pers) + not@adv ]
           else
              1(verb_pers))
       else
          (if (1.negative = neg)
              [ 1(verb_nopers) + not@adv ]
           else
              1(verb_nopers))
       );

!!! MACROS !!!

qst_front: (if (1.lem = жат or 1.lem = э)
               be(vaux)[pos_tag=vbser,
                        person=1.person, number=1.number, tense=1.tense,
                        negative=1.negative, qst=NOqst, lemcase=1.lemcase]
            else-if (1.lem = ал)
               can(vaux)[pos_tag=vbmod,
                         person=1.person, number=1.number, tense=1.tense,
                         negative=1.negative, qst=NOqst, lemcase=1.lemcase]
            else
               do(vaux)[pos_tag=vbdo,
                        person=1.person, number=1.number, tense=1.tense,
                        negative=1.negative, qst=NOqst, lemcase=1.lemcase]);

!qst_front: (always *(vaux)[lemh=(if (1.lem = жат or 1.lem = э) be
!                                 if (1.lem = ал) can
!                                 else do),
!                           pos_tag=(if (1.lem = жат or 1.lem = э) vbser
!                                    if (1.lem = ал) vbmod
!                                    else vbdo),
!                           person=1.person, number=1.number, tense=1.tense,
!                           negative=1.negative, qst=NOqst, lemcase=1.lemcase]);


!!! RULES !!!

NP ->	0: np.$nptype.$lem/sl.$case/sl.$poss [$number=sg,$prep_flag=1.case/sl>prep_flag] { 1 } |
      1: n.$nptype.$lem/sl.$case/sl.$number.$poss [$prep_flag=(if (1.lem in en_nouns_loc_in) in else 1.case/sl>prep_flag)] { 1 } |
      2: np.top.loc.$nptype.$poss ?(1.lem/sl in city) [$case=loc,$prep_flag=in,$number=sg] { 1 } |
      3: np.top.loc.$nptype.$poss                     [$case=loc,$prep_flag=on,$number=sg] { 1 } |
!      2: np.top.loc.$nptype.$poss [$case=loc,$number=sg] { in@prep _ 1 } (1.lem/sl in city)
!                                { at@prep _ 1 } |
      4: n.nom n.px3sp.$case.$nptype [$number=sg] { 1 _1 2 } | ! $poss=2.poss
      NP cnjcoo %NP [$number=pl,$nptype=1.nptype] { 1 _1 2 _2 3 } | ! FIXME: having trouble making $nptype dynamic
      np.ant.$nptype n.$case/sl.$number.$poss ?((2.lem/sl in ky_titles) and (2.poss = noPOSS)) { 2 _1 1 }
   ;

AP -> adj ?(1.adj_behaviour not = advl) { 1 } |
      adv.attr { 1 } |
      "# year-old" num жашар@adj { 1 _1 2 } |
      AP AP { 1 _1 2 } |
      AdvP adj { 1 _1 2 }
;
!|
 !     AP { 1 } ;

dP ->
!      4: NP.*.gen NP.*.[px3].$number.$case [$prep_flag=(if (2.lem in prep_nouns) noPr else 2.prep_flag)] {
!! FIXME: can't get the following to work:
!         (if (2.lem in prep_nouns)
!           [ 2[lemh=2.lemh>preposition] _1 the@det.def.sp _ 1 ]
!          else
!           [ 1 's@gen _1 2 ]
!         ) } |
!!           1 's@gen _1 2 } |
!! COMMENT OUT THE ABOVE LINE once the FIXME above is fixed
!      4: NP.*.gen NP.*.[px3].$number.$case.$prep_flag { 2 _1 of@pr _ 1 } |
!		! The following are hacks.
!		! They should really be [DP [DP[det NP.gen]] NP.px3]
!      4: det NP.*.gen NP.*.[px3].$number.$case.$prep_flag { 1 _1 2 's@gen _2 3 } |
!      4: det NP.*.gen NP.*.[px3].$number.$case.$prep_flag { 1 _1 3 _2 of@pr _ 2 } |
!      NP.*.gen AP det NP.*.[px3].$number.$case.$prep_flag { 1 's@gen _1 3 _3 2 _2 4 } |
!      det NP.$number.$case.$prep_flag.$poss { 1[number=2.number] _1 2 } |
!      det AP NP.$number.$case.$prep_flag.$poss { 1 _1 2 _2 3 } |
!		num NP.$number.$case.$prep_flag.$poss ?(2.lem not = жаш ) { 1 _1 2 } |
!		num жаш@NP.$number.$case.$poss          [$prep_flag=NOpr] { 1 _1 year@n.pl _ old@adj.sint } |
!		num AP NP.$number.$case.$prep_flag.$poss { 1 _1 2 _2 3 } |
!      det num AP NP.$number.$case.$prep_flag.$poss { 1 _1 2 _2 3 _3 4 } |
      ! FIXME: what to do about this??
      AP det %NP { 2 _2 1 _1 3 } |
!      0: NP.n.$number.$case.$prep_flag.$poss {
!          (if (1.poss = noPOSS)
!               [ the@det.def.sp ]
!             else
!               [ prpers@det.pos.[1.poss>person].[1.poss>gender].[1.poss>number] ]
!          ) _ 1 } |
!      1: NP.n.$number.$case.$prep_flag.$poss { a@det.idf.sp _ 1 } |
!      2: %NP.np.$number.$case.$prep_flag.$poss { 1 } |
!      0: AP NP.$number.$case.$prep_flag.$poss { the@det.def.sp _ 1 _1 2 } |
!      1: AP NP.$number.$case.$prep_flag.$poss { a@det.idf.sp _ 1 _1 2 } |
      2: %prn { (if (1.person = p1 and 1.number = sg) 1[lemcase=Aa]
                      else 1[lemcase=$lemcase]) } |
!      RC DP.$number.$case.$poss { 2 _1 that@cnjsub _ 1 } |
!		VP.ger { 1 } |
      AP %NP { 1 _1 2 } |
      %NP { 1 }
   ;

DP ->
      0: %dP { 1 } |
      1: %dP { a@det.idf.sp _ 1 } |
      1: %dP { the@det.def.sp _ 1 } |
      det %dP { 1[number=2.number] _1 2 } |
      0: num %dP { 1 _1 2 } |
		1: num %жаш@dP [$prep_flag=NOpr] { 1 _1 year@n.pl _ old@adj.sint } |
      det num %dP { 1[number=3.number] _1 2 _2 3 } |
      2: %dP.np { 1 } |
      2: %dP.n {
          (if (1.poss = noPOSS)
               [ the@det.def.sp ]
             else
               [ prpers@det.pos.[1.poss>person].[1.poss>gender].[1.poss>number] ]
          ) _ 1 } |
      RC %dP.$number.$case.$poss { 2 _1 that@cnjsub _ 1 } |
		VP.ger [$nptype=ger] { 1 } |
      !!! ATTEMPT TO FIX NP.gen NP.px3 rules
      !4: DP.*.gen DP.*.[px3].$number.$case.$prep_flag { 2 _1 of@pr _ 1 } |
      !4: DP.*.gen DP.*.[px3].$number.$case.$prep_flag { 1 _1 's@gen _ 2 } |
      4: DP.*.gen %dP.*.[px3] [$prep_flag=(if (2.lem in prep_nouns) noPr else 2.prep_flag)] {
         (if (2.lem in prep_nouns)
           [ 2[lemh=2.lemh>preposition] _1 the@det.def.sp _ 1 ]
          else
           [ 1 's@gen _1 2 ]
         ) }
   ;

RC -> DP.*.nom VP.prc { 1 _1 2 } |
      VP.prc { 1 }
;

PP -> 1: DP.$prep_flag ?(1.case in might_get_pr)
         (if ($prep_flag = NOpr)
             { 1 }
          else
             { (if (($prep_flag = to) or (1.case = dat))
                   [ to@pr _ ]
                else-if ($prep_flag = at)
                   [ at@pr _ ]
                else-if ($prep_flag = in)
                   [ in@pr _ ]
                else-if ($prep_flag = on)
                   [ on@pr _ ]
                else-if ($prep_flag = of)
                   [ of@pr _ ]
                else-if (($prep_flag = from) or (1.case = abl))
                   [ from@pr _ ]
                else
                   []
                )
                1 } ) |
      DP post { 2 _1 1 } ;

VP -> PP DP.[definiteness].prep_flag %vP { %3 _2 2 _1 1 } |
      DP.[definiteness].prep_flag DP.[definiteness].prep_flag %vP { 3[number=$number] _2 2 _1 1 } |
!      DP.oblique DP.acc %vP { 3 _2 2 _1 1 } |
      DP %vP.cop { %2 _1 1 } |
      AP %vP.cop { %2 _1 1 } |
      AdvP AP %vP.cop { %3 _2 2 _1 1 } |
      adv.itg %vP.cop { %2 _1 1 } |
      DP DP %vP
!         ?(~((1.case = nom) and (2.case = nom) and ((3.fnf = prc) or (3.transitivity = cop)))) ! don't match <nom> <nom> <prc> or <nom> <nom> <cop> → these are handled by other rules
         ?(
            ((2.case = nom) and (1.case in might_get_pr)) or
            ((2.case = acc) and (1.case in might_get_pr))
          )
            (if ((1.case = nom) and (2.case = acc))
                { 1 _1 %3 _2 2 }
             else
                { %3 _2 2 _1 1 } ) |
      DP DP %vP
         ?(
            ((1.case = nom) and (2.case in might_get_pr)) or
            ((1.case = acc) and (2.case in might_get_pr))
          )
            { %3 _2 1 _1 2 } |
      DP %vP.$lem
         ?(not
            (
               ((2.passive = pass) or (2.transitivity = iv))
               and (1.case = nom)
            )
          ) { %2 _1 1 } |
      2: VP.ger %vP.$lem
         ?(not
            (
               ((2.passive = pass) or (2.transitivity = iv))
               and (1.case = nom)
            )
          ) { %2 _1
               (if (2.lem in ky_verbs_ing)
                  [ 1[en_nonfin=pprs] ]
                else
                  [ %1 ]
               )
            } |
      PP DP.*.acc %vP { %3 _2 2 _1 1 } |
      PP PP %vP { %3 _2 2 _1 1 } |
      PP %vP.$lem
         { %2 _1
            (if (2.lem in ky_verbs_dat_arg)
               1[prep_flag=NOpr]
             else
               1
            )
         } |
      DP AdvP %vP
         ?((1.case = acc))
         { %3 _1 1 _2 2 } |
      DP PP %vP
         ?((1.case = acc))
         { %3 _1 1 _2 2 } |
      PP AdvP %vP { 3 _2 2 _1 1 } |
      AdvP %vP { %2 _1 1 } |
      %vP { %1 } |
      S %де@vP { %2 _1 1 }
   ;

AdvP -> adj.advl.$advlevel [$adv_behaviour=NOadvB] {
          (if ($advlevel = comp) [ more@adv _ ] ) 1 } |
        %adv { 1 } ;

!      0: v.$transitivity { 1 } |
!      1: NP.acc v.$transitivity { 2 _1 1 } |
!      2: NP NP v.$transitivity
!         { 3 _2 the@det.def.sp _2 2 _1 to@pr 1 }
!         { 3 _2 the@det.def.sp _2 2 _1 1 }        ( 3.lem in en_verbs_nopr )
!    |
!      3: DP. VP                                   ( 3.lem in en_verbs_nopr )
!      4: NP.dat NP.nom v.$transitivity { 3 _2 2 _1 1 } ;

!v -> 0: v.$tenseetc vaux { 2(vaux_thing) _1 1 } ;
!v -> 0: v.$tenseetc vaux.$tense { 2 _1 1 } ;

prc_or_tense = [prc] [tense] ;
prc_or_tense > tense : prc_past past ;
frontable = be can ;

vP -> 0: v.$transitivity %vaux.$tense.$lem/sl [$fnf=2.fnfall>fnf, $negative=(if (1.negative = neg or 2.negative = neg) neg else pos)]
          (if (2.lem/tl in frontable and $qst = qst)
              { (if (2.lem/tl = be) 1[tense=pprs, negative=pos] else 1[tense=inf, negative=pos]) }
           else-if (2.lem/tl in en_vaux_ing)
              { 2[tense=$tense, qst=$qst, number=$number] _1 1[tense=pprs] }
           else-if (2.lem/tl in en_vaux_none)
              { 2[tense=$tense, qst=$qst, number=$number, negative=$negative] _1 1[tense=inf] }
           else ! 2.lem in en_vaux_to
              { 2[person=1.person, number=1.number, tense=$tense, qst=$qst, number=$number] _1 to@pr _1 1[tense=inf] } )
       |
      !1: v.$transitivity.$tense [$fnf=1.fnfall>fnf]
      !    (if ((1.person=p3) and (1.number=sg))
      !        { 1[person=p3, number=sg] }
      !     else
      !        { 1[person=_, number=_] }
      !    )
      ! |
		! en_nonfin
      1: %v.$transitivity.$lem/sl [$fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          (if ((1.passive/sl = pass) and ($qst not = qst))
              { be@vbser.$tense.[1.person].[1.number] _ 1[tense=pp] }
           else
              { %1 } ) |
      2: %v.*.neg.$transitivity.$lem/sl [$fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          (if ($qst = qst)
              { 1[tense=inf, negative=pos] }
           else
              { do@vbdo.$tense _ not@adv _ 1[tense=inf, negative=pos] } ) |

      3: %cop.$lem/sl [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { (if ($qst not = qst) %1) } |
      4: %cop.neg.$lem/sl [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { (if ($qst not = qst) %1) _ not@adv } |

      3: %бол@v ?(1.lem/tl = be) [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { %1 } |
      4: %бол@v.*.neg ?(1.lem/tl = be) [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { %1 _ not@adv } |
      5: %v.$transitivity.$lem/sl бар@v.iv.prc_impf жат@vaux [$fnf=3.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 3 _1 %1[tense=pprs] }
;




S -> 2: DP.*.nom VP.fin
       { 1 _1
               (if ((2.number = sg) and (1.number = pl))
                    2[number=pl]
                else 2
               )
       } |
     2: DP.*.nom.$lemcase VP qst { 2(qst_front)[lemcase=$lemcase] _ 1[lemcase=aa] _1 2[qst=qst] } |
     VP.fin { prpers@prn.subj.[1.person].[1.gender].[1.number] _ 1 }
;
