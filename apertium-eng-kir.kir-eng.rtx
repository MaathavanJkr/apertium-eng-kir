!!! ATTRIBUTE LISTS !!!

number = (ND sg) sg pl sp ;
case = (CD subj) nom acc dat gen loc abl subj obj ;
oblique = (CD obj) acc dat loc abl obj ;
prontype = pers dem ;
!tenseetc = ifi past aor pres prc_perf prc_ipf ;
!nonfinite = prc_perf, pprs, prc_impf, pprs ;
person = (PD p3) p1 p2 p3 ;
transitivity = tv iv cop ;
gender = (GD m) m f mf nt ;
definiteness = (DD def) ind def ;
prep_flag = (PRD none) to in on at for PRD none;
                 ! ^ hack, but not all NPs have prep_flag set, which overrides <dat> and this no pr
adjlevel = cmp ;
adjtype = sint ;
adv_behaviour = attr ;
advlevel = cmp ;
nptype = n np ;
det_type = dem ;

fnf = fin prc vadj vadv ger ;
    ! finite, non-finite
tense = (TD pres) pres aor ifi past ;  ! finites
prc = (PTD pprs) prc_past prc_impf prc_irre pprs pp ;  ! select -ing if in doubt
vadv = gna_perf ;
ger = ger ger_past ;
vadj = gpr_past ;
voice = pass caus ;
fnfall = [tense] [prc] [vadv] [ger] [vadj] ;

poss = px1sg px2sg px3sg px1pl px2pl px3pl;

en_nouns_mass = bread paper ;
en_nouns_count = window paper ;

en_verbs_nopr = believe touch enter reach cross leave;
ky_verbs_dat_arg = ишен тий кир жет;
ky_verbs_abl_arg = өт аш;
en_vaux_ing = be ;
en_vaux_to = want ;

en_vaux_person = be have ;

might_get_pr = loc dat abl gen ;

city = Нарын ;


!!! MAPPINGS !!!

poss > person : px1sg p1, px2sg p2, px3sg p3, px1pl p1, px2pl p2, px3pl p3;
poss > number : px1sg sg, px2sg sg, px3sg sg, px1pl pl, px2pl pl, px3pl pl;
tense > tense : aor pres, ifi past ;
nonfinite > nonfinite : prc_perf pprs, prc_impf pprs ;
prc > tense : prc_perf pprs, prc_impf pprs ;
case > case : nom subj, acc obj, dat obj ;
fnfall > fnf : [tense] fin, [prc] prc, [vadv] vadv, [ger] ger, [vadj] vadj ;

!!! OUTPUT PATTERNS !!!
! when building chunk or lu of this type, put these tags in this order

NP: _.nptype.case.prep_flag.number ;
DP: _.case.prep_flag ;
VP: _.fnf ;
np: _ ;
prn: _.case.person.gender.number ;
S: _ ;
n: _.number ;
v: _.tense ;
adj: _.adjtype.adjlevel ;
vP: _.transitivity.tense.fnf;
PP: _ ;
AP: _ ;
det_dem: _.<dem>.number ;
det_def: _.definite.number ;
det: (if (1.det_type = dem) 1[det_dem] else 1[det_def]);
adv_attr: _ ;
adv_default: _.advlevel ;
adv: (if (1.adv_behaviour = attr) 1[adv_attr] else 1[adv_default]);
vAux: _.tense.person.number ;
vaux: _.tense.person.number ;
cop: _.tense.person.number ;
!vbser: _.tense.person.number ;

!vaux_thing: lemh.<vbser>.tense.person.number ;


!!! RULES !!!

NP ->	0: np.$nptype.$lem/sl.$case/sl [$number=sg] { 1 } |
      1: n.$nptype.$lem/sl.$case/sl.$number { 1 } |
      2: np.top.loc.$nptype ?(1.lem/sl in city) [$case=loc,$prep_flag=in,$number=sg] { 1 } |
      3: np.top.loc.$nptype                     [$case=loc,$prep_flag=on,$number=sg] { 1 } |
!      2: np.top.loc.$nptype [$case=loc,$number=sg] { in@prep _ 1 } (1.lem/sl in city)
!                                { at@prep _ 1 } |
      4: n.nom n.px3sp.$case.$nptype [$number=sg] { 1 _1 2 }
   ;

AP -> adj { 1 } |
      adv.attr { 1 } ;
!|
 !     AP { 1 } ;

DP -> det NP.$case.$prep_flag { 1(number=2.number) _1 2 } |
      det AP NP.$case.$prep_flag { 1 _1 2 _2 3 } |
      0: NP.$case.$prep_flag { the@det.def.sp _ 1 } |
      1: NP.$case.$prep_flag { a@det.idf.sp _ 1 } |
      0: AP NP.$case.$prep_flag { the@det.def.sp _ 1 _1 2 } |
      1: AP NP.$case.$prep_flag { a@det.idf.sp _ 1 _1 2 } |
      2: prn.$case { 1 } |
      VP.prc DP.$case { 2 _1 that@cnjsub _ 1 }
   ;

PP -> DP ?(1.case in might_get_pr)
         (if ((1.prep_flag = none) or (1.prep_flag = PRD))
             { (if (1.case = gen)
                   [ of@pr _ ]
                else-if (1.case = abl)
                   [ from@pr _ ]
                else-if (1.case = dat)
                   [ to@pr _ ]
                else
                   []
               )
				 1 }
          else
             { (if ((1.prep_flag = to) or (1.case = dat))
                   [ to@pr _ ]
                else-if (1.prep_flag = at)
                   [ at@pr _ ]
                else-if (1.prep_flag = in)
                   [ in@pr _ ]
                else-if (1.prep_flag = on)
                   [ on@pr _ ]
                else-if (1.prep_flag = from)
                   [ from@pr _ ]
                else
                   []
                )
                1 } );

VP -> PP DP.[definiteness].prep_flag vP.$transitivity.$fnf { 3 _2 2 _1 1 } |
      DP.[definiteness].prep_flag DP.[definiteness].prep_flag vP.$transitivity.$fnf { 3 _2 2 _1 1 } |
!      DP.oblique DP.acc vP.$fnf { 3 _2 2 _1 1 } |
      DP vP.cop.$fnf { 2 _1 1 } |
      DP DP vP.$fnf.$transitivity
!         ?(~((1.case = nom) and (2.case = nom) and ((3.fnf = prc) or (3.transitivity = cop)))) ! don't match <nom> <nom> <prc> or <nom> <nom> <cop> → these are handled by other rules
         ?(
            ((2.case = nom) and (1.case in might_get_pr)) or
            ((2.case = acc) and (1.case in might_get_pr))
          )
            (if ((1.case = nom) and (2.case = acc))
                { 1 _1 3 _2 2 }
             else
                { 3 _2 2 _1 1 } ) |
      DP vP.$fnf { 1 _1 2 } |
      PP DP.acc vP.$fnf { 3 _2 2 _1 1 } |
      PP PP vP.$fnf.$transitivity { 3 _2 2 _1 1 } |
      PP vP.$fnf.$transitivity { 2 _1 1 }
   ;


!      0: v.$transitivity { 1 } |
!      1: NP.acc v.$transitivity { 2 _1 1 } |
!      2: NP NP v.$transitivity
!         { 3 _2 the@det.def.sp _2 2 _1 to@pr 1 }
!         { 3 _2 the@det.def.sp _2 2 _1 1 }        ( 3.lem in en_verbs_nopr )
!    |
!      3: DP. VP                                   ( 3.lem in en_verbs_nopr )
!      4: NP.dat NP.nom v.$transitivity { 3 _2 2 _1 1 } ;

!v -> 0: v.$tenseetc vaux { 2[vaux_thing] _1 1 } ;
!v -> 0: v.$tenseetc vaux.$tense { 2 _1 1 } ;

prc_or_tense = [prc] [tense] ;
prc_or_tense > tense : prc_past past ;

vP -> 0: v.$transitivity vAux.$tense [$fnf=1.fnfall>fnf]
          (if (2.lem in en_vaux_ing)
              { 2 _1 1(tense=pprs) }
           else ! 2.lem in en_vaux_to
              { 2(person=1.person, number=1.number) _1 to@pr _1 1(tense=inf) } )
       |
      !1: v.$transitivity.$tense [$fnf=1.fnfall>fnf]
      !    (if ((1.person=p3) and (1.number=sg))
      !        { 1(person=p3, number=sg) }
      !     else
      !        { 1(person=_, number=_) }
      !    )
      ! |
      1: v.$transitivity.$lem/sl [$fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          (if (1.voice/sl = pass)
              { be@vbser.$tense.$person.$number _ 1(tense=pp) }
           else
              { 1(tense=$tense) } ) |
      2: v.*.neg.$transitivity.$lem/sl [$fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { do@vbdo.$tense _ not@adv _ 1(tense=inf) } |

      3: cop [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) } |
      4: cop.neg [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) _ not@adv } |

      3: бол@v ?(1.lem/tl = be) [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) } |
      4: бол@v.*.neg ?(1.lem/tl = be) [$transitivity=cop, $fnf=1.fnfall>fnf, $tense=1.prc_or_tense>tense]
          { 1(tense=$tense) _ not@adv } ;



vAux -> vaux.$lemh (if (1.lem not in en_vaux_person)
                       { 1(person=_, number=_) }
                    else
                       { 1 } )
     ;



S -> DP.nom VP.fin { 1 _1 2 } ;
